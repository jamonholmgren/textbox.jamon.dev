<!DOCTYPE html>
<!--

  Hey there! Thanks for looking at my source code.

  I'm Jamon Holmgren, author of this tiny website. I'd be honored if you would contribute
  to this and make it better!

  The rules:
  
  1. One file only, no dependencies
  2. The source code has to be readable

  If you like this little experiment, hit me up on Twitter: https://twitter.com/jamonholmgren

  Happy writing!

-->
<html lang="en">
  <head>
    <title>textbox.page - Simple text box for writing</title>
    <meta
      name="description"
      content="Simple autosaving text box for writing and editing text. No accounts, no tracking, just a text box."
    />
    <meta name="viewport" content="width=device-width" />
    <style>
      :root {
        /* Dark theme (default) */
        --bg-color: #252526;
        --textarea-bg: #212121;
        --text-color: #b9b9b9;
        --settings-bg: #333333;
      }

      [data-theme="light"] {
        --bg-color: #ffffff;
        --textarea-bg: #f5f5f5;
        --text-color: #333333;
        --settings-bg: #e0e0e0;
      }

      [data-theme="sepia"] {
        --bg-color: #f4ecd8;
        --textarea-bg: #fbf7ef;
        --text-color: #5f4b32;
        --settings-bg: #ede6d4;
      }

      [data-theme="dusk"] {
        --bg-color: #2d1b2e;
        --textarea-bg: #3a2042;
        --text-color: #e6ddf9;
        --settings-bg: #582b5e;
      }

      html,
      body {
        background: var(--bg-color);
        height: 100%;
        padding: 0;
        margin: 0;
        font-family: monospace;
        transition: background 0.3s ease;
        display: flex;
        flex-direction: column;
      }

      [data-theme="dusk"] body {
        background: linear-gradient(135deg, #2d1b2e 0%, #582b5e 100%);
      }

      [data-theme="dusk"] #t {
        background: linear-gradient(to bottom, #3a2042 0%, #2d1b2e 100%);
        border: 1px solid #582b5e;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        color: #e6ddf9;
      }

      [data-theme="dusk"] .settings-group select,
      [data-theme="dusk"] .settings-group input {
        background: rgba(58, 32, 66, 0.8);
        border: 1px solid #582b5e;
        color: #e6ddf9;
      }

      [data-theme="dusk"] #byline a,
      [data-theme="dusk"] #byline a:visited {
        color: #f9c846;
        border-bottom: 1px dotted #f9c846;
      }

      [data-theme="dusk"] #byline a:hover {
        border-bottom: 1px solid #f9c846;
      }

      main {
        width: 100%;
        flex: 1;
        min-height: 0; /* Important for flex child to shrink properly */
        display: flex;
        flex-direction: column;
        padding: 10px 0;
        box-sizing: border-box;
      }

      #t {
        display: block;
        width: 92%;
        padding: 3%;
        flex: 1;
        min-height: 0; /* Important for flex child to shrink properly */
        margin: 0 auto;
        background: var(--textarea-bg);
        font-size: 18px;
        color: var(--text-color);
        border: 1px solid #000000;
        font-family: Helvetica, sans-serif;
        tab-size: 2;
        transition: color 0.3s ease, background-color 0.3s ease; /* Only transition colors, not size */
        resize: none; /* Disable resize since we're using flexbox */
      }

      #t.codemode {
        font-family: monospace;
      }

      #t.font-mono {
        font-family: monospace;
      }

      #t.font-courier {
        font-family: "Courier New", Courier, monospace;
      }

      #t.font-consolas {
        font-family: Consolas, Monaco, "Andale Mono", monospace;
      }

      #t.font-serif {
        font-family: "Georgia", serif;
      }

      #t.font-sans {
        font-family: Helvetica, Arial, sans-serif;
      }

      #t.font-garamond {
        font-family: Garamond, "Times New Roman", serif;
      }

      #t.font-palatino {
        font-family: "Palatino Linotype", Palatino, serif;
      }

      #t.font-verdana {
        font-family: Verdana, Geneva, sans-serif;
      }

      #t.font-tahoma {
        font-family: Tahoma, Geneva, sans-serif;
      }

      #t.font-trebuchet {
        font-family: "Trebuchet MS", sans-serif;
      }

      #t.font-bookman {
        font-family: "Bookman Old Style", serif;
      }

      #byline {
        width: 100%;
        text-align: center;
        font-size: 13px;
        color: var(--text-color);
        padding: 10px 5%;
        line-height: 1.5;
        box-sizing: border-box;
        flex-shrink: 0; /* Prevent footer from shrinking */
      }

      #byline a,
      #byline a:visited {
        color: var(--text-color);
        text-decoration: none;
        border-bottom: 1px dotted var(--text-color);
      }

      #byline a:hover {
        border-bottom: 1px solid var(--text-color);
      }

      .settings-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        margin: 8px auto;
        max-width: 800px;
      }

      .settings-group {
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .settings-group label {
        margin-right: 3px;
        white-space: nowrap;
      }

      .settings-group select,
      .settings-group input {
        padding: 2px 4px;
        background: var(--textarea-bg);
        color: var(--text-color);
        border: 1px solid var(--text-color);
        border-radius: 3px;
      }

      .settings-group input[type="range"] {
        width: 60px;
        margin: 0;
      }

      #stats {
        margin: 5px 0;
      }

      .divider {
        display: inline-block;
        margin: 0 5px;
      }

      /* Mobile responsiveness */
      @media (max-width: 768px) {
        .settings-container {
          flex-direction: column;
          align-items: center;
          gap: 5px;
          margin: 5px auto;
        }

        .settings-group {
          width: 100%;
          justify-content: center;
        }

        #byline {
          font-size: 11px;
          margin: 0.5% auto;
        }

        .divider {
          display: none;
        }

        main {
          height: 70%;
        }
      }

      .offscreen {
        clip-path: inset(100%);
        clip: rect(1px 1px 1px 1px);
        height: 1px;
        overflow: hidden;
        position: absolute;
        white-space: nowrap;
        width: 1px;
      }
    </style>
  </head>
  <body>
    <script>
      // if it's textbox.page, tell them it'll expire soon and to update
      // their bookmark to textbox.jamon.dev
      if (window.location.hostname === "textbox.page") {
        alert(
          "Hey there! It looks like you're using textbox.page. I'm going to let this domain expire. Please update your bookmark to textbox.jamon.dev. Thanks!"
        );
      }
    </script>
    <main>
      <label for="t" class="offscreen"
        >Text area for typing notes and code</label
      >
      <textarea id="t"></textarea>
    </main>
    <div id="byline">
      <div class="settings-container">
        <div class="settings-group">
          <label for="theme">Theme:</label>
          <select id="theme" onchange="updateSetting('theme', this.value)">
            <option value="dark">Dark</option>
            <option value="dusk">Dusk</option>
            <option value="light">Light</option>
            <option value="sepia">Sepia</option>
          </select>
        </div>

        <div class="settings-group">
          <label for="font">Font:</label>
          <select id="font" onchange="updateSetting('font', this.value)">
            <!-- Font options will be populated dynamically based on mode -->
          </select>
        </div>

        <div class="settings-group">
          <label for="fontSize">Size:</label>
          <input
            type="range"
            id="fontSize"
            min="12"
            max="24"
            value="18"
            onchange="updateSetting('fontSize', this.value)"
            oninput="updateFontSizePreview(this.value)"
          />
          <span id="fontSizeValue">18px</span>
        </div>

        <div class="settings-group">
          <label for="modeSelect">Mode:</label>
          <select id="modeSelect" onchange="setMode(this.value)">
            <option value="writing">Writing</option>
            <option value="code">Code</option>
          </select>
        </div>
      </div>

      <div id="stats">0 lines, 0 words, 0 characters, 0 elapsed seconds</div>

      <div>
        Built by
        <a href="https://jamonholmgren.com" target="_blank" rel="noopener"
          >Jamon Holmgren</a
        >
        <span class="divider">&bull;</span>
        <a
          href="https://github.com/jamonholmgren/jamon.dev/blob/main/web/static/notes.html"
          target="_blank"
          rel="noopener"
          >GitHub Source</a
        >
        <span class="divider">&bull;</span>
        <a href="https://infinite.red" target="_blank" rel="noopener"
          >Infinite Red</a
        >
      </div>
    </div>

    <script>
      var TAB_TEXT = "\t";
      var mode = "writing";
      var DEFAULT_TEXT =
        "Hey there! This is a simple textbox that you can paste, write, edit, and copy from. We'll remember what you wrote, even if you close the tab and come back. But don't worry -- we only store the information locally in your browser, not any servers or databases. We don't even have Google Analytics installed. Try the 'Code Mode' in the settings!";
      var t = document.getElementById("t");

      function setMode(newMode) {
        const previousMode = mode;
        mode = newMode;

        // Save current font before switching modes
        if (previousMode !== mode) {
          const currentFont = getCurrentFont();
          saveModeFont(previousMode, currentFont);
        }

        if (mode === "code") {
          t.classList.add("codemode");
          // If current font is not a monospace font, set it to the saved monospace font or default
          if (!isMonospaceFont(getCurrentFont())) {
            const savedCodeFont = getModeFont("code");
            updateSetting("font", savedCodeFont || "mono", false);
          }
        } else {
          t.classList.remove("codemode");
        }

        // Update the select element
        document.getElementById("modeSelect").value = mode;

        // Update font options based on mode
        updateFontOptions();

        // Restore the font for this mode
        const savedFont = getModeFont(mode);
        if (savedFont) {
          updateSetting("font", savedFont, false); // Don't save to general settings

          // Make sure the font dropdown reflects the current font
          const fontSelect = document.getElementById("font");
          if (fontSelect) fontSelect.value = savedFont;
        }

        // Save the mode
        localStorage.setItem("mode", mode);
      }

      function saveModeFont(mode, font) {
        const modeFonts = JSON.parse(localStorage.getItem("modeFonts") || "{}");
        modeFonts[mode] = font;
        localStorage.setItem("modeFonts", JSON.stringify(modeFonts));
      }

      function getModeFont(mode) {
        const modeFonts = JSON.parse(localStorage.getItem("modeFonts") || "{}");
        return modeFonts[mode];
      }

      function getCurrentFont() {
        const fontClass = t.className.match(/font-(\w+)/);
        return fontClass ? fontClass[1] : "sans";
      }

      function isMonospaceFont(font) {
        return ["mono", "courier", "consolas"].includes(font);
      }

      function updateFontOptions() {
        const fontSelect = document.getElementById("font");
        const currentFont = getCurrentFont();

        // Clear existing options
        fontSelect.innerHTML = "";

        // Add all font options regardless of mode
        // Sans-serif fonts
        addFontOption(
          fontSelect,
          "sans",
          "Sans-serif",
          currentFont === "sans",
          mode === "code" && !isMonospaceFont("sans")
        );
        addFontOption(
          fontSelect,
          "verdana",
          "Verdana",
          currentFont === "verdana",
          mode === "code" && !isMonospaceFont("verdana")
        );
        addFontOption(
          fontSelect,
          "tahoma",
          "Tahoma",
          currentFont === "tahoma",
          mode === "code" && !isMonospaceFont("tahoma")
        );
        addFontOption(
          fontSelect,
          "trebuchet",
          "Trebuchet MS",
          currentFont === "trebuchet",
          mode === "code" && !isMonospaceFont("trebuchet")
        );

        // Serif fonts
        addFontOption(
          fontSelect,
          "serif",
          "Georgia",
          currentFont === "serif",
          mode === "code" && !isMonospaceFont("serif")
        );
        addFontOption(
          fontSelect,
          "garamond",
          "Garamond",
          currentFont === "garamond",
          mode === "code" && !isMonospaceFont("garamond")
        );
        addFontOption(
          fontSelect,
          "palatino",
          "Palatino",
          currentFont === "palatino",
          mode === "code" && !isMonospaceFont("palatino")
        );
        addFontOption(
          fontSelect,
          "bookman",
          "Bookman",
          currentFont === "bookman",
          mode === "code" && !isMonospaceFont("bookman")
        );

        // Monospace fonts
        addFontOption(
          fontSelect,
          "mono",
          "Monospace",
          currentFont === "mono",
          false // Never disable monospace fonts
        );
        addFontOption(
          fontSelect,
          "courier",
          "Courier New",
          currentFont === "courier",
          false // Never disable monospace fonts
        );
        addFontOption(
          fontSelect,
          "consolas",
          "Consolas",
          currentFont === "consolas",
          false // Never disable monospace fonts
        );

        // After adding all options, make sure the correct one is selected
        if (fontSelect.value !== currentFont) {
          fontSelect.value = currentFont;
        }
      }

      function addFontOption(
        selectElement,
        value,
        text,
        isSelected,
        isDisabled
      ) {
        const option = document.createElement("option");
        option.value = value;
        option.text = text;
        option.selected = isSelected;
        if (isDisabled) {
          option.disabled = true;
          option.style.color = "#888";
        }
        selectElement.add(option);
      }

      var startTime = new Date().getTime();
      var stats = document.getElementById("stats");
      function updateStats() {
        var lines = t.value.split("\n").length;
        var words = t.value.split(/\s+/).filter(function (word) {
          return word.length > 0;
        }).length;
        var chars = t.value.length;
        var seconds = Math.floor((new Date().getTime() - startTime) / 1000);
        var secondsMinutes =
          seconds < 59
            ? seconds + " elapsed seconds"
            : Math.floor(seconds / 60) + " elapsed minutes";
        stats.innerText =
          lines +
          " lines, " +
          words +
          " words, " +
          chars +
          " characters, " +
          secondsMinutes;
      }
      setInterval(updateStats, 1000);

      function ready(fn) {
        (
          document.attachEvent
            ? document.readyState === "complete"
            : document.readyState !== "loading"
        )
          ? fn()
          : document.addEventListener("DOMContentLoaded", fn);
      }

      ready(function () {
        mode = localStorage.getItem("mode") || "writing";
        setMode(mode);

        t.value = localStorage.getItem("text") || DEFAULT_TEXT;
        loadSettings();

        // Make sure font options are updated based on mode
        updateFontOptions();

        t.addEventListener("input", function (ev) {
          localStorage.setItem("text", t.value);
          updateStats();
        });
        t.select();
        t.focus();
      });

      // loading this tab key handler async for performance reasons
      // adapted from https://stackoverflow.com/a/45396754/204044
      var loadAsync = function () {
        function tabHandler(e) {
          if (mode !== "code") return;
          if (e.keyCode === 13) {
            // prettier-ignore
            if (this.selectionStart === this.selectionEnd) {
              var sel = this.selectionStart;
              var text = this.value;
              while (sel > 0 && text[sel - 1] != "\n") sel--;
              var lineStart = sel;
              while (text[sel] == " " || text[sel] == "\t") sel++;
              if (sel > lineStart) {
                document.execCommand("insertText", false, "\n" + text.substr(lineStart, sel - lineStart));
                this.blur(); this.focus(); e.preventDefault(); return false;
              }
            }
          } else if (e.keyCode === 9) {
            e.preventDefault();
            // prettier-ignore
            if (this.selectionStart === this.selectionEnd) {
              if (!e.shiftKey) {
                document.execCommand("insertText", false, "\t");
              } else {
                if (this.selectionStart > 0 && this.value[this.selectionStart - 1] == "\t") document.execCommand("delete");
              }
            } else {
              var selStart = this.selectionStart;
              var selEnd = this.selectionEnd;
              while (selStart > 0 && this.value[selStart - 1] != "\n") selStart--;
              while (selEnd > 0 && this.value[selEnd - 1] != "\n" && selEnd < this.value.length) selEnd++;
              var lines = this.value.substr(selStart, selEnd - selStart).split("\n");
              for (var i = 0; i < lines.length; i++) {
                if (i == lines.length - 1 && lines[i].length == 0) continue;
                if (e.shiftKey) {
                  if (lines[i].startsWith("\t")) lines[i] = lines[i].substr(1);
                  else if (lines[i].startsWith("    ")) lines[i] = lines[i].substr(4);
                } else lines[i] = "\t" + lines[i];
              }
              lines = lines.join("\n");
              this.value = this.value.substr(0, selStart) + lines + this.value.substr(selEnd);
              this.selectionStart = selStart;
              this.selectionEnd = selStart + lines.length;
            }
          }
        }
        t.addEventListener("keydown", tabHandler, false);
      };
      setTimeout(loadAsync, 1000);

      function updateFontSizePreview(value) {
        // Update the display value
        document.getElementById("fontSizeValue").textContent = `${value}px`;

        // Update the font size in real-time
        t.style.fontSize = `${value}px`;
      }

      function updateSetting(setting, value, saveToSettings = true) {
        switch (setting) {
          case "theme":
            document.documentElement.setAttribute("data-theme", value);
            break;
          case "font":
            // Remove any existing font classes
            t.className = t.className.replace(/font-\w+/g, "").trim();

            // Add the new font class
            t.classList.add(`font-${value}`);

            // Keep codemode class if in code mode
            if (mode === "code") {
              t.classList.add("codemode");
            }

            // Save font preference for current mode
            if (saveToSettings) {
              saveModeFont(mode, value);
            }
            break;
          case "fontSize":
            // Font size is already updated in real-time by updateFontSizePreview
            // This just saves the setting
            break;
        }

        // Save settings
        if (saveToSettings) {
          const settings = JSON.parse(localStorage.getItem("settings") || "{}");
          settings[setting] = value;
          localStorage.setItem("settings", JSON.stringify(settings));
        }
      }

      // Load settings
      function loadSettings() {
        const settings = JSON.parse(localStorage.getItem("settings") || "{}");

        if (settings.theme) {
          document.getElementById("theme").value = settings.theme;
          document.documentElement.setAttribute("data-theme", settings.theme);
        }

        // Get mode-specific font if available
        const modeFont = getModeFont(mode);
        const fontToUse =
          modeFont || settings.font || (mode === "code" ? "mono" : "sans");

        // Clear existing font classes first
        t.className = t.className.replace(/font-\w+/g, "").trim();
        t.classList.add(`font-${fontToUse}`);

        // Update font options first, then set the selected value
        updateFontOptions();

        // Now set the font dropdown value directly
        const fontSelect = document.getElementById("font");
        if (fontSelect) {
          setTimeout(() => {
            fontSelect.value = fontToUse;
          }, 0);
        }

        if (settings.fontSize) {
          const fontSize = settings.fontSize;
          document.getElementById("fontSize").value = fontSize;
          document.getElementById(
            "fontSizeValue"
          ).textContent = `${fontSize}px`;
          t.style.fontSize = `${fontSize}px`;
        }

        // Make sure code mode class is applied if needed
        if (mode === "code") {
          t.classList.add("codemode");
        }
      }
    </script>
  </body>
</html>
